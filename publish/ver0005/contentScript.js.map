{"version":3,"file":"contentScript.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://playground-chromeextension/./src/Error/Error.ts","webpack://playground-chromeextension/./src/utils/constants.ts","webpack://playground-chromeextension/./src/utils/helpers.ts","webpack://playground-chromeextension/./src/utils/selectors.ts","webpack://playground-chromeextension/webpack/bootstrap","webpack://playground-chromeextension/webpack/runtime/define property getters","webpack://playground-chromeextension/webpack/runtime/hasOwnProperty shorthand","webpack://playground-chromeextension/webpack/runtime/make namespace object","webpack://playground-chromeextension/./src/contentScript/contentScript.ts"],"sourcesContent":["class Err {\r\n    constructor(message) {\r\n        this.message = message;\r\n        this.name = 'Error';\r\n    }\r\n}\r\nexport class ErrorBase extends Err {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n    }\r\n}\r\nexport class DomManipulationError extends ErrorBase {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'DomManipulationError';\r\n    }\r\n}\r\n/***********\r\n * Among contentScript.js\r\n * Thrown if subtitle is not English, or Transcript is not opened\r\n * */\r\nexport class PageStatusNotReadyError extends ErrorBase {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'PageStatusNotReadyError';\r\n    }\r\n}\r\n","// Valid URL pattern.\r\nexport const urlPattern = /https:\\/\\/www.udemy.com\\/course\\/*/gm;\r\n//\r\n// --- RELATED TO MESSAGE PASSING -------------\r\n//\r\n// message passingで利用する拡張機能名称\r\nexport const extensionNames = {\r\n    popup: 'popup',\r\n    contentScript: 'contentScript',\r\n    controller: 'controller',\r\n    captureSubtitle: 'captureSubtitle',\r\n    background: 'background',\r\n};\r\n// message passingで利用する共通order名称\r\nexport const orderNames = {\r\n    // From background to contentScript\r\n    sendStatus: 'sendStatus',\r\n    // from controller to background\r\n    sendSubtitles: 'sendSubtitles',\r\n    // from popup, run process\r\n    run: 'run',\r\n    // reset content script\r\n    reset: 'reset',\r\n    // Turn Off ExTranscript\r\n    turnOff: 'turnOff',\r\n    // something succeeded\r\n    success: 'success',\r\n    // Is the page moved to text page?\r\n    isPageIncludingMovie: 'isPageIncludingMovie',\r\n    // Alert\r\n    alert: 'alert',\r\n};\r\n// --- RELATED TO background.ts --------------\r\n// Key for chrome.storage.local in background.ts\r\nexport const _key_of_model_state__ = '_key_of_model_state__@&%8=8';\r\nexport const _key_of_localstorage__ = '__key__of_local_storage__@&%8=8';\r\nexport const copies = {};\r\n// TODO: まだlocalStorageにこの情報が残っているかも...\r\n// const _key_of_localstorage__ = \"__key__of_local_storage__\";\r\n// --- RELATED TO controller.ts -----------------\r\n// transcript要素はwinodwサイズが975px以下の時にdashboardへ以上でsidebarへ移動する\r\n// export const RESIZE_BOUNDARY: number = 975;\r\nexport const RESIZE_BOUNDARY = 963;\r\n// window onResize時の反応遅延速度\r\nexport const RESIZE_TIMER = 100;\r\nexport const positionStatus = {\r\n    sidebar: 'sidebar',\r\n    noSidebar: 'noSidebar',\r\n};\r\nexport const messageTemplate = {\r\n    appCannotExecute: '[拡張機能:Re Transcript] 拡張機能が実行不可能なエラーが起こりました。お手数ですが拡張機能をOFFにして展開中のページをリロードしてください。',\r\n    letPagePrepare: '[拡張機能:Re Transcript] トランスクリプトと字幕表示をONにして、字幕言語を英語にしてから再度実行してください。',\r\n};\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\n// Returns deep copied data.\r\nexport const deepCopier = (data) => {\r\n    return JSON.parse(JSON.stringify(data));\r\n};\r\n/**\r\n * Promise will be solved when receiver returns response with { complete: true } object.\r\n *\r\n * If there is not { complete: true } object, then it throws exception.\r\n *\r\n * This is different from sendMessagePromise().\r\n * */\r\nexport const sendMessageToTabsPromise = (tabId, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.tabs.sendMessage(tabId, message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            complete\r\n                ? resolve(rest)\r\n                : reject('Send message to tabs went something wrong');\r\n        }));\r\n    }));\r\n});\r\n/**\r\n * Promise will be solved when receiver returns response with { complete: true } object.\r\n *\r\n * If there is not { complete: true } object, then it throws exception.\r\n *\r\n * This is different from sendMessageToTabsPromise().\r\n * */\r\nexport const sendMessagePromise = (message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.runtime.sendMessage(message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            if (complete)\r\n                resolve(rest);\r\n            else\r\n                reject();\r\n        }));\r\n    }));\r\n});\r\n/**\r\n * Returns Tab info of tab that active and last time focused\r\n *\r\n * @return {chrome.tabs.Tab[0]} - Returns first Tab info unless it gets multiple tabs info.\r\n * */\r\nexport const tabQuery = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const w = yield chrome.windows.getCurrent();\r\n        const tabs = yield chrome.tabs.query({\r\n            active: true,\r\n            currentWindow: true,\r\n            lastFocusedWindow: true,\r\n        });\r\n        return tabs[0];\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n// Returns strings without after \"#\" charactor.\r\nexport const exciseBelowHash = (url) => {\r\n    return url.indexOf('#') < 0 ? url : url.slice(0, url.indexOf('#'));\r\n};\r\n/*********************\r\n * Repeat given async callback function.\r\n *\r\n * @param {action} Function:\r\n * the function that will be executed repeatedly.\r\n * NOTE: Function must returns boolean.\r\n * @param {timesoutResolve} boolean: true to allow this function to return false.\r\n * @param {times} number: Number that how many times repeat.\r\n * Default to 10.\r\n * @param {interval} number: Microseconds that repeat interval.\r\n * Default to 200.\r\n * @return {Promise} Promise objects represents boolean. True as matched, false as no-matched.\r\n * @throws\r\n *\r\n * Ref：https://stackoverflow.com/questions/61908676/convert-setinterval-to-promise\r\n *\r\n * Ref：https://levelup.gitconnected.com/how-to-turn-settimeout-and-setinterval-into-promises-6a4977f0ace3\r\n * */\r\nexport const repeatActionPromise = (action, timeoutAsResolve = false, interval = 200, times = 10) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => {\r\n        let intervalId;\r\n        let triesLeft = times;\r\n        intervalId = setInterval(function () {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (yield action()) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了としてtrueを返す\r\n                    resolve(true);\r\n                }\r\n                else if (triesLeft <= 1 && timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了でfalseを返す\r\n                    resolve(false);\r\n                }\r\n                else if (triesLeft <= 1 && !timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 例外エラーとしてcatchされる\r\n                    reject();\r\n                }\r\n                triesLeft--;\r\n            });\r\n        }, interval);\r\n    });\r\n});\r\n/****************\r\n * Wrapper of setTimeout with given function.\r\n *\r\n *\r\n * */\r\nexport const delay = (action, timer) => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(function () {\r\n            const r = action();\r\n            resolve(r);\r\n        }, timer);\r\n    });\r\n};\r\n// --- USAGE EXAMPLE --------------------------------------\r\n// const randomMath = (): boolean => {\r\n//   return Math.random() * 0.8 > 400 ? true : false;\r\n// }\r\n// const repeatQuerySelector = async (): Promise<boolean> => {\r\n//   try {\r\n//     // 第二引数をfalseにすると、ループで一度もマッチしなかった場合、例外エラーになる\r\n//     // なので例外エラーにしたくなくて、falseも受け取りたいときは\r\n//     // 第二引数をtrueにすること\r\n//       const r: boolean = await repeatActionPromise(\r\n//           function(): boolean {return randomMath()}, true\r\n//       );\r\n//       return r;\r\n//   }\r\n//   catch(err) {\r\n//\r\n//       // console.error(`Error: Could not query dom. ${err.message}`)\r\n//       throw err;\r\n//   }\r\n// }\r\n// (async function() {\r\n//   const res = await repeatQuerySelector();\r\n//\r\n//\r\n// })();\r\n","/***************************************************\r\n * SELECTORS\r\n *\r\n * Including:\r\n * - Ud*my elements selectors.\r\n * - re-transcript generated elements selectors.\r\n *\r\n * **************************************************/\r\n// --- Selectors related to Transcript ---------------------------\r\n// Ud*my講義ページが動画ページならこのセレクタが一致する\r\n// テキストページとかなら一致しない\r\nexport const videoContainer = 'div.video-viewer--container--23VX7';\r\n// new added. Ud*myページのNavbarヘッダ\r\nexport const header = '.header--header--3k4a7';\r\nexport const transcript = {\r\n    // HTMLSpanElement which is Highlight as current subtitle on movie.\r\n    highlight: 'span.transcript--highlight-cue--1bEgq',\r\n    // NodeListOf<HTMLSpanElement> which are list of subtitle element.\r\n    transcripts: 'div.transcript--cue-container--wu3UY p.transcript--underline-cue--3osdw span',\r\n    // top element of side bar\r\n    noSidebar: 'div.app--no-sidebar--1naXE',\r\n    sidebar: 'div.has-sidebar',\r\n    // High level element of Movie element\r\n    movieContainer: 'div.app--curriculum-item--2GBGE',\r\n    // Movie Replay button\r\n    replayButton: \"button[data-purpose='video-play-button-initial']\",\r\n    // Controlbar\r\n    controlbar: \"div.control-bar--control-bar--MweER[data-purpose='video-controls']\",\r\n    // Footer of Transcript when it is sidebar.\r\n    footerOfSidebar: '.transcript--autoscroll-wrapper--oS-dz',\r\n    // new added. 自動スクロールチェックボックス\r\n    // AutoScroll Checkbox\r\n    autoscroll: \"[name='autoscroll-checkbox']\",\r\n};\r\n// --- Selectors related to control bar. -------------------------\r\nexport const controlBar = {\r\n    // \"closed captioning\"\r\n    cc: {\r\n        // 字幕メニューpopupボタン\r\n        popupButton: \"button[data-purpose='captions-dropdown-button']\",\r\n        // textContentで取得できる言語を取得可能\r\n        //   languageList:\r\n        //     \"button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral > div.udlite-block-list-item-content\",\r\n        //\r\n        // 言語リストを取得するには一旦languageButtonsを取得してからそれからquerySelectorする\r\n        // いらないかも\r\n        menuCheckButtons: 'button',\r\n        menuList: '.ud-block-list-item-content',\r\n        menuListParent: \"ul[role='menu'][data-purpose='captions-dropdown-menu']\",\r\n        // 上記のセレクタのラッパーボタン。\r\n        // 属性`aria-checked`で選択されているかどうかわかる\r\n        checkButtons: 'button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral',\r\n    },\r\n    transcript: {\r\n        toggleButton: \"button[data-purpose='transcript-toggle']\",\r\n    },\r\n    theatre: {\r\n        theatreToggle: \"button[data-purpose='theatre-mode-toggle-button']\",\r\n    },\r\n};\r\n// --- Selectors related ex-transcript -----------------------\r\nexport const EX = {\r\n    // Ud*my page-specific selector\r\n    sidebarParent: '.app--content-column--HC_i1',\r\n    noSidebarParent: '.app--dashboard-content--r2Ce9',\r\n    movieContainer: '.app--body-container',\r\n    // 独自selector `ex--`を接頭辞とする\r\n    // sidebar ex-transcript selectors\r\n    sidebarWrapper: '.ex-sidebar__column',\r\n    sidebarSection: '.ex-sidebar__sidebar',\r\n    sidebarHeader: '.ex-sidebar__header',\r\n    sidebarContent: '.ex-sidebar__content',\r\n    sidebarContentPanel: '.ex-transcript__panel',\r\n    sidebarCueContainer: '.ex-transcript__cue-container',\r\n    // recently added. '.ex-transcript__cue-container'の子要素のparagraphのclass名\r\n    sidebarCue: '.ex-transcript__cue',\r\n    // recently added. .ex-transcript__cue'の子要素のspan要素のdata-purposeの指定値\r\n    sidebarCueSpan: 'ex-transcript__cue--text',\r\n    sidebarFooter: '.ex-sidebar__footer',\r\n    // sidebar width in case more than SIDEBAR_WIDTH_BOUNDARY\r\n    wideView: '.ex--sidebar--wideview',\r\n    // sidebar width in case less than SIDEBAR_WIDTH_BOUNDARY\r\n    middleView: '.ex--sidebar--middleview',\r\n    // bottom ex-transcript selectors\r\n    dashboardTranscriptWrapper: '.ex-dashboard-transcript__wrapper',\r\n    dashboardTranscriptHeader: '.ex-dashboard-transcript__header',\r\n    dashboardTranscriptPanel: '.ex-dashboard-transcript__transcript--panel',\r\n    dashboardTranscriptCueContainer: '.ex-dashboard-transcript__transcript--cue-container',\r\n    dashboardTranscriptCue: '.ex-dashboard-transcript__transcript--cue',\r\n    // data-purpose\r\n    dashboardTranscriptCueText: 'ex--dashboard-cue-text',\r\n    dashboardTranscriptBottom: '.ex-dashboard-transcript__footer',\r\n    // To Highlight Transcriot Cue Container\r\n    highlight: '.--highlight',\r\n    closeButton: '.btn__close',\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**********************************************************\r\n * content script\r\n *\r\n * Functionality:\r\n * 1. Watch if Transcript is turning on.\r\n * 2. Watch if subtitle language is English.\r\n * 3. Send result of 1 and 2 to background script.\r\n *\r\n * Watch control bar on movie container to detect click event on it.\r\n * Watch toggle buttons on control bar appeared or dispappeared by using moControlbar.\r\n * This content script will be injected dynamically.\r\n * Communicate with background script by using single message passing.\r\n *\r\n * *********************************************************/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport * as selectors from '../utils/selectors';\r\nimport { extensionNames, orderNames, } from '../utils/constants';\r\nimport { sendMessagePromise, repeatActionPromise } from '../utils/helpers';\r\nimport { DomManipulationError } from '../Error/Error';\r\n//\r\n// --- GLOBALS ---------------------------------------------------\r\n//\r\nconst INTERVAL_TIME = 500;\r\n// Delay to wait finish event.\r\nconst DELAY_AFTER_EVENT = 200;\r\nlet moControlbar = null;\r\nlet controlbar = null;\r\n//\r\n// --- CHROME API LISTENERS -------------------------------------\r\n//\r\n/**\r\n * Message Handler\r\n *\r\n * @param {iMessage} message\r\n * @param {function} sendResponse:\r\n * Invoke this function to response. The function is required.\r\n * @return {boolean} - MUST RETURN TRUE TO RUN sendResponse asynchronously.\r\n *\r\n *  1. sendStatus:\r\n *   Survey the subtitle language is English or not,\r\n *   and Transcript is open or not.\r\n *\r\n *  2. reset\r\n *    Run initialize() and respond result.\r\n *\r\n *  3. isPageIncludingMovie\r\n *    Survey the page is including Movie container or not.\r\n *\r\n *  4. turnOff\r\n *    Disconnect MutationObserver and remove event listener from Controlbar\r\n * */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    const { from, order, to } = message;\r\n    const response = {\r\n        from: extensionNames.contentScript,\r\n        to: from,\r\n    };\r\n    if (to !== extensionNames.contentScript)\r\n        return;\r\n    // ORDERS:\r\n    if (order && order.length) {\r\n        // SEND STATUS\r\n        if (order.includes(orderNames.sendStatus)) {\r\n            //\r\n            try {\r\n                const isEnglish = isSubtitleEnglish();\r\n                let isOpen = false;\r\n                const toggle = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n                if (!toggle)\r\n                    isOpen = false;\r\n                else\r\n                    isOpen = isTranscriptOpen();\r\n                response.language = isEnglish;\r\n                response.isTranscriptDisplaying = isOpen;\r\n                // response.success = true;\r\n                response.complete = true;\r\n            }\r\n            catch (err) {\r\n                // response.success = false;\r\n                response.error = err;\r\n                response.complete = false;\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n        // RESET\r\n        if (order.includes(orderNames.reset)) {\r\n            handlerOfReset()\r\n                .then(() => {\r\n                response.success = true;\r\n                response.complete = true;\r\n            })\r\n                .catch((e) => {\r\n                console.error(e.message);\r\n                response.success = false;\r\n                response.complete = false;\r\n                response.error = e;\r\n            })\r\n                .finally(() => {\r\n                sendResponse(response);\r\n            });\r\n        }\r\n        // Is the page including Movie Container?\r\n        if (order.includes(orderNames.isPageIncludingMovie)) {\r\n            repeatCheckQueryAcquired(selectors.videoContainer, true)\r\n                .then((r) => {\r\n                response.isPageIncludingMovie = r;\r\n                response.complete = true;\r\n            })\r\n                .catch((err) => {\r\n                console.error(err);\r\n                response.complete = false;\r\n                response.error = err;\r\n            })\r\n                .finally(() => {\r\n                sendResponse(response);\r\n            });\r\n        }\r\n        // TURN OFF\r\n        if (order.includes(orderNames.turnOff)) {\r\n            moControlbar.disconnect();\r\n            controlbar.removeEventListener('click', handlerOfControlbar);\r\n            // moControlbar and controlbar should be null?\r\n            response.complete = true;\r\n            sendResponse(response);\r\n        }\r\n    }\r\n    return true;\r\n});\r\n/**\r\n *  Sends status of injected page to background.\r\n *\r\n * @param order:\r\n * @param {boolean} isOpened - True as Transcript is open.\r\n * @param {boolean} isEnglish - True as subtitle language is English.\r\n * */\r\nconst sendToBackground = (order) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { isOpened, isEnglish } = order;\r\n    const m = {\r\n        from: extensionNames.contentScript,\r\n        to: extensionNames.background,\r\n    };\r\n    if (isOpened !== undefined) {\r\n        m['isTranscriptDisplaying'] = isOpened;\r\n    }\r\n    if (isEnglish !== undefined) {\r\n        m['language'] = isEnglish;\r\n    }\r\n    yield sendMessagePromise(m);\r\n});\r\n//\r\n// ---- MAJOUR HANDLERS -----------------------------------------\r\n//\r\n/**\r\n * Handler of RESET order.\r\n *\r\n * Invoke initialize().\r\n * */\r\nconst handlerOfReset = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        yield initialize();\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/**\r\n *  Handler of Click Event on Controlbar\r\n *\r\n * @param {PointEvent} ev\r\n *\r\n *\r\n * setTimeout() callback will be fired after click event has been done immediately.\r\n *\r\n * */\r\nconst handlerOfControlbar = function (ev) {\r\n    //\r\n    // Get DOMs among click event.\r\n    const path = ev.composedPath();\r\n    // DOM: toggle button of Transcript\r\n    const transcriptToggle = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n    // Toggle button of theater mode.\r\n    const theaterToggle = document.querySelector(selectors.controlBar.theatre.theatreToggle);\r\n    // Menu of Closed Caption\r\n    const ccPopupMenu = document.querySelector(selectors.controlBar.cc.menuListParent);\r\n    // Callback will be run after Click event has done.\r\n    setTimeout(function () {\r\n        // If either toggle button clicked...\r\n        // Check Transcript toggle button is exist.\r\n        // If exist, invoke isTranscriptOpen().\r\n        // If no, send result to background script.\r\n        if (path.includes(transcriptToggle) || path.includes(theaterToggle)) {\r\n            let result;\r\n            const t = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n            if (!t)\r\n                result = false;\r\n            else\r\n                result = isTranscriptOpen();\r\n            sendToBackground({ isOpened: result });\r\n        }\r\n        // If click event has happend in cc popup menu,\r\n        // find out if the subtitle language has been changed,\r\n        // or if subtitle setting has been changed.\r\n        if (path.includes(ccPopupMenu)) {\r\n            if (isItSelectLanguageMenu()) {\r\n                const r = isSubtitleEnglish();\r\n                sendToBackground({ isEnglish: r });\r\n            }\r\n        }\r\n    }, DELAY_AFTER_EVENT);\r\n};\r\n//\r\n// --- SURVEY METHODS --------------------------------------------\r\n//\r\n/**\r\n * Check Transcript is opened or not.\r\n *\r\n * @returns {boolean}: true for open, false for not open.\r\n *\r\n * Get DOM everytime this function invoked.\r\n * */\r\nconst isTranscriptOpen = () => {\r\n    const toggleButton = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n    return toggleButton.getAttribute('aria-expanded') === 'true' ? true : false;\r\n};\r\n/***\r\n * Is subtitle language is English?\r\n *\r\n *\r\n * @returns {boolean}: True as it's English, false as not.\r\n * @throws {DomManipulationError} : When dom acquisition failes.\r\n * Exception might be happen when selector is not matches.\r\n *\r\n * DOMs:\r\n * - listParent: Parent element of CC popup menu.\r\n * - checkButtons: Listed button elements on CC popup menu. It includes attributed that express selected or not.\r\n * - menuList: child elements of checkButtons's button element. The innerText includes languages that express subtitle languages.\r\n *\r\n * Process:\r\n * 1. Find out which language is selected by checking attribute boolean value.\r\n * 2. If it was true, save the counter of loop.\r\n * 3. Find out language by saved counter number.\r\n * 4. If it was English, then return true. (If no, return false).\r\n * */\r\nconst isSubtitleEnglish = () => {\r\n    const listParent = document.querySelector(selectors.controlBar.cc.menuListParent);\r\n    const checkButtons = listParent.querySelectorAll(selectors.controlBar.cc.menuCheckButtons);\r\n    const menuList = listParent.querySelectorAll(selectors.controlBar.cc.menuList);\r\n    if (!listParent || !checkButtons.length || !menuList.length)\r\n        throw new DomManipulationError('Failed to manipulate DOM');\r\n    let counter = 0;\r\n    let i = null;\r\n    const els = Array.from(checkButtons);\r\n    for (const btn of els) {\r\n        if (btn.getAttribute('aria-checked') === 'true') {\r\n            i = counter;\r\n            break;\r\n        }\r\n        counter++;\r\n    }\r\n    if (!i) {\r\n        throw new Error('Error: No language is selected or failed to retrieve DOM');\r\n    }\r\n    const currentLanguage = Array.from(menuList)[i].innerText;\r\n    if (currentLanguage.includes('English') || currentLanguage.includes('英語'))\r\n        return true;\r\n    else\r\n        return false;\r\n};\r\n//\r\n// --- OBSERVER METHODS -----------------------------------------\r\n//\r\nconst config = {\r\n    attributes: false,\r\n    childList: true,\r\n    subtree: false,\r\n};\r\n/***\r\n * Watch controlbar\r\n * to find out transcript toggle button is appeared or disappeared.\r\n * Everytime appearing and disappearing, then let background script to know.\r\n *\r\n * */\r\nconst moCallback = (mr) => {\r\n    let guard = false;\r\n    mr.forEach((record) => {\r\n        if (record.type === 'childList' && !guard) {\r\n            guard = true;\r\n            // Added Nodes\r\n            record.addedNodes.forEach((node) => {\r\n                const dataPurpose = node.childNodes[0].parentElement.firstElementChild.getAttribute('data-purpose');\r\n                if (dataPurpose && dataPurpose === 'transcript-toggle') {\r\n                    sendToBackground({ isOpened: isTranscriptOpen() });\r\n                }\r\n            });\r\n            // Removed Nodes\r\n            record.removedNodes.forEach((node) => {\r\n                const dataPurpose = node.childNodes[0].parentElement.firstElementChild.getAttribute('data-purpose');\r\n                if (dataPurpose && dataPurpose === 'transcript-toggle') {\r\n                    sendToBackground({ isOpened: false });\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n//\r\n// ---- OTHER METHODS -------------------------------------------\r\n//\r\n/***\r\n * Find out the element is exist which matches with passed selector.\r\n * @param {string} selector - Seletor that about to find out.\r\n * @return {boolean} - true as exist, false as not exist.\r\n * */\r\nconst investTheElementIncluded = (selector) => {\r\n    const e = document.querySelector(selector);\r\n    return e ? true : false;\r\n};\r\n/**************************************************\r\n * Repeat to run investTheElementIncluded function.\r\n *\r\n * @param {string} selector : selector for dom about to acquire.\r\n * @param {boolean} timeoutAsResolve: If true, then timeout will not occure error.\r\n * @return {boolean} : Return boolean result. True as dom acquired. False as not.\r\n *\r\n * */\r\nconst repeatCheckQueryAcquired = (selector, timeoutAsResolve = false) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        return yield repeatActionPromise(function () {\r\n            return investTheElementIncluded(selector);\r\n        }, timeoutAsResolve, 100, 10);\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/*************************************************\r\n * Repeat to try query dom by given selector.\r\n * @param {string} selector: Selector for dom about to acquire.\r\n * @return {promise} represents HTMLElement as success.\r\n * @throws {DomManipulationError}\r\n *\r\n * */\r\nconst repeatQuerySelector = (selector) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        yield repeatCheckQueryAcquired(selector);\r\n        return document.querySelector(selector);\r\n    }\r\n    catch (err) {\r\n        throw new DomManipulationError(`Error: Could not retrieve DOM with the selector ${selector}`);\r\n    }\r\n});\r\n/***\r\n * Determine what the CC popup menu is showing.\r\n *\r\n * Menu might be...\r\n * - \"Select subtitle language\"\r\n * - \"Setting of subtitle\"\r\n *\r\n * @return {boolean} - True as the menu is showing \"Select subtitle language\" menu. False as \"Setting of subtitle\" menu.\r\n *\r\n * NOTE: DO INVOKE THIS FUNCTION everytime onClick event happend on CC popup menu!\r\n * */\r\nconst isItSelectLanguageMenu = () => {\r\n    const menu = document.querySelector('div.control-bar-dropdown--menu--2bFbL.control-bar-dropdown--menu-dark--3cSQg > ul[data-purpose=\"captions-dropdown-menu\"] > li[role=\"none\"] > ul[aria-label=\"字幕\"] > button');\r\n    return menu ? true : false;\r\n};\r\n/*****************************************\r\n *  Initialize for detecting injected page status.\r\n *\r\n *  set up controlbar click event listener.\r\n *  set up MutationObserver of controlbar.\r\n *\r\n * Among initialize process, stop MutationObserver.\r\n * And restart MutationObserver when done.\r\n * */\r\nconst initialize = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        // For a moment stop MutationObserevr.\r\n        if (moControlbar)\r\n            moControlbar.disconnect();\r\n        moControlbar = null;\r\n        moControlbar = new MutationObserver(moCallback);\r\n        // Retrieve controlbar DOM again.\r\n        if (controlbar)\r\n            controlbar.removeEventListener('click', handlerOfControlbar);\r\n        controlbar = null;\r\n        controlbar = yield repeatQuerySelector(selectors.transcript.controlbar);\r\n        controlbar.addEventListener('click', handlerOfControlbar);\r\n        // Restart MutationObserver with retrieved controlbar DOM.\r\n        moControlbar.observe(controlbar, config);\r\n    }\r\n    catch (err) {\r\n        if (err instanceof DomManipulationError)\r\n            console.error(`DomManipulationError: ${err.message}`);\r\n        throw err;\r\n    }\r\n});\r\n/**\r\n * Entry Point\r\n *\r\n * */\r\n(function () {\r\n    initialize().catch((e) => {\r\n        chrome.runtime.sendMessage({\r\n            from: extensionNames.contentScript,\r\n            to: extensionNames.background,\r\n            success: false,\r\n            error: e,\r\n        });\r\n    });\r\n})();\r\n"],"names":[],"sourceRoot":""}