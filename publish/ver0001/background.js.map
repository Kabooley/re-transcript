{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://playground-chromeextension/./src/background/annotations.ts","webpack://playground-chromeextension/./src/utils/Circulater.ts","webpack://playground-chromeextension/./src/utils/constants.ts","webpack://playground-chromeextension/./src/utils/helpers.ts","webpack://playground-chromeextension/./src/utils/repeatPromise.ts","webpack://playground-chromeextension/webpack/bootstrap","webpack://playground-chromeextension/webpack/runtime/define property getters","webpack://playground-chromeextension/webpack/runtime/hasOwnProperty shorthand","webpack://playground-chromeextension/webpack/runtime/make namespace object","webpack://playground-chromeextension/./src/background/background.ts"],"sourcesContent":["// base object for State<iProgress>\r\nexport const progressBase = {\r\n    isContentScriptInjected: false,\r\n    isCaptureSubtitleInjected: false,\r\n    isControllerInjected: false,\r\n    isSubtitleCapturing: false,\r\n    isSubtitleCaptured: false,\r\n    isExTranscriptStructured: false,\r\n};\r\n// Base object that satisfies iModel.\r\nexport const modelBase = {\r\n    // contentScript.js has been injected or not.\r\n    isContentScriptInjected: false,\r\n    // captureSubtitles.js has been injected or not.\r\n    isCaptureSubtitleInjected: false,\r\n    // controller.js has been injected or not.\r\n    isControllerInjected: false,\r\n    // Subtitles data is capturing now or not.\r\n    isSubtitleCapturing: false,\r\n    // It is done capturing subtitles data or not.\r\n    isSubtitleCaptured: false,\r\n    // ExTranscript is structured or not.\r\n    isExTranscriptStructured: false,\r\n    // There is Udemy Transcript shown or not.\r\n    // Not means turining on or not.\r\n    // If not shown, ExTranscript also not to be either.\r\n    isTranscriptDisplaying: false,\r\n    // Udemy subtitle language is English or not.\r\n    isEnglish: false,\r\n    // Tab id that this extension is now running.\r\n    tabId: null,\r\n    // URL that this extension is now running.\r\n    url: null,\r\n    // Captured subtitles data.\r\n    subtitles: null,\r\n    // Tab info that this extension is now running.\r\n    tabInfo: null,\r\n};\r\n","/*************************************************\r\n * ここの内容はまるっきりrepeatPromise.tsの内容と同じかも...\r\n *\r\n * ***********************************************/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/****************************************\r\n * circulater\r\n *\r\n * High order function that returns the function\r\n * which repeats given function until given times.\r\n *\r\n * @param {iCallbackOfCirculater} callback - Function that you want to iterate over.\r\n * @param {iConditionOfCirculater} conditon - Function that gives conditiobal branching to continue or terminate.\r\n * @param {number} until - Number how many times to repeat.\r\n * @return {iClosureOfCirculater<T>} - function which repeats given function until given times.\r\n *\r\n * resultが初期化されないのにreturnしているというエラーがでるかも\r\n * */\r\nexport const circulater = function (callback, condition, until) {\r\n    return function () {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // 予めループの外にresult変数を置いて\r\n            let result;\r\n            for (let i = 0; i < until; i++) {\r\n                result = yield callback();\r\n                if (condition(result))\r\n                    return result;\r\n            }\r\n            // ループが終わってしまったら最後のresultを返せばいいのだが...\r\n            // エラーを出すかも:\r\n            // \"TypeScriptがresultが初期化されないままなんだけど\"\r\n            //\r\n            // 必ずresultはforループで初期化されるからってことを\r\n            // TypeScriptへ伝えたいけど手段がわからん\r\n            return result;\r\n        });\r\n    };\r\n};\r\n/// USAGE //////////////////////////////////////////////////////\r\n// // 実際に実行したい関数\r\n// const counter = async (times: number): Promise<boolean> => {\r\n//   return new Promise((resolve, reject) => {\r\n//     let timerId: number;\r\n//     let num: number = 0;\r\n//     timerId = setInterval(function () {\r\n//\r\n//       if (num >= times) {\r\n//         clearInterval(timerId);\r\n//         const random_boolean = Math.random() < 0.7;\r\n//         resolve(random_boolean ? true : false);\r\n//       } else num++;\r\n//     }, 1000);\r\n//   });\r\n// };\r\n// // circulaterへ渡すcallback関数\r\n// //\r\n// // 完全にハードコーディング\r\n// //\r\n// // 実際に実行したい関数へ渡さなくてはならない引数はここで渡すこと\r\n// // 戻り値は任意であるが、condition関数のgenerics型と同じにすること\r\n// const cb: iCallbackOfCirculater<boolean> = async (): Promise<boolean> => {\r\n//   const n: boolean = await counter(7);\r\n//\r\n//   return n;\r\n// };\r\n// // circulaterへ渡すconditon関数\r\n// //\r\n// // 完全にハードコーディング\r\n// //\r\n// // circulaterへ渡す引数callbackの戻り値の型と同じ型をgenericsとして渡すこと\r\n// const counterCondition: iConditionOfCirculater<iOp> = (\r\n//   operand: iOp\r\n// ): boolean => {\r\n//\r\n//   return operand ? true : false;\r\n// };\r\n// const counterLoop = circulater<boolean>(cb, counterCondition, 3);\r\n// (async function () {\r\n//   const r = await counterLoop();\r\n//\r\n// })();\r\n","// Valid URL pattern.\r\nexport const urlPattern = /https:\\/\\/www.udemy.com\\/course\\/*/gm;\r\n//\r\n// --- RELATED TO MESSAGE PASSING -------------\r\n//\r\n// message passingで利用する拡張機能名称\r\nexport const extensionNames = {\r\n    popup: 'popup',\r\n    contentScript: 'contentScript',\r\n    controller: 'controller',\r\n    captureSubtitle: 'captureSubtitle',\r\n    background: 'background',\r\n};\r\n// message passingで利用する共通order名称\r\nexport const orderNames = {\r\n    // From background to contentScript\r\n    sendStatus: 'sendStatus',\r\n    // from controller to background\r\n    sendSubtitles: 'sendSubtitles',\r\n    // from popup, run process\r\n    run: 'run',\r\n    // reset content script\r\n    reset: 'reset',\r\n    // Turn Off ExTranscript\r\n    turnOff: 'turnOff',\r\n    // something succeeded\r\n    success: 'success',\r\n    // Is the page moved to text page?\r\n    isPageIncludingMovie: 'isPageIncludingMovie',\r\n    // Alert\r\n    alert: 'alert',\r\n};\r\n// --- RELATED TO background.ts --------------\r\n// Key for chrome.storage.local in background.ts\r\nexport const _key_of_model_state__ = '_key_of_model_state__@&%8=8';\r\nexport const _key_of_localstorage__ = '__key__of_local_storage__@&%8=8';\r\nexport const copies = {};\r\n// TODO: まだlocalStorageにこの情報が残っているかも...\r\n// const _key_of_localstorage__ = \"__key__of_local_storage__\";\r\n// --- RELATED TO controller.ts -----------------\r\n// transcript要素はwinodwサイズが975px以下の時にdashboardへ以上でsidebarへ移動する\r\n// export const RESIZE_BOUNDARY: number = 975;\r\nexport const RESIZE_BOUNDARY = 963;\r\n// window onResize時の反応遅延速度\r\nexport const RESIZE_TIMER = 100;\r\nexport const positionStatus = {\r\n    sidebar: 'sidebar',\r\n    noSidebar: 'noSidebar',\r\n};\r\n// Template message for alert.\r\n// export const messageTemplate = {\r\n//     appCannotExecute:\r\n//         'Problem occured that the extension not being able to run. Please turn off the extension or reload the page.',\r\n//     letPagePrepare:\r\n//         'Please turn on Transcript and choose English for subtitle language.',\r\n// };\r\nexport const messageTemplate = {\r\n    appCannotExecute: '[re-transcript] 拡張機能が実行不可能なエラーが起こりました。お手数ですが拡張機能をOFFにして展開中のページをリロードしてください。',\r\n    letPagePrepare: '[re-transcript] トランスクリプトと字幕表示をONにして、字幕言語を英語にしてから再度実行してください。',\r\n};\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\n// Returns deep copied data.\r\nexport const deepCopier = (data) => {\r\n    return JSON.parse(JSON.stringify(data));\r\n};\r\n/**\r\n * Promise will be solved when receiver returns response with { complete: true } object.\r\n *\r\n * If there is not { complete: true } object, then it throws exception.\r\n *\r\n * This is different from sendMessagePromise().\r\n * */\r\nexport const sendMessageToTabsPromise = (tabId, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.tabs.sendMessage(tabId, message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            complete\r\n                ? resolve(rest)\r\n                : reject('Send message to tabs went something wrong');\r\n        }));\r\n    }));\r\n});\r\n/**\r\n * Promise will be solved when receiver returns response with { complete: true } object.\r\n *\r\n * If there is not { complete: true } object, then it throws exception.\r\n *\r\n * This is different from sendMessageToTabsPromise().\r\n * */\r\nexport const sendMessagePromise = (message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.runtime.sendMessage(message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            if (complete)\r\n                resolve(rest);\r\n            else\r\n                reject();\r\n        }));\r\n    }));\r\n});\r\n/**\r\n * Returns Tab info of tab that active and last time focused\r\n *\r\n * @return {chrome.tabs.Tab[0]} - Returns first Tab info unless it gets multiple tabs info.\r\n * */\r\nexport const tabQuery = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const w = yield chrome.windows.getCurrent();\r\n        const tabs = yield chrome.tabs.query({\r\n            active: true,\r\n            currentWindow: true,\r\n            lastFocusedWindow: true,\r\n        });\r\n        return tabs[0];\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n// Returns strings without after \"#\" charactor.\r\nexport const exciseBelowHash = (url) => {\r\n    return url.indexOf('#') < 0 ? url : url.slice(0, url.indexOf('#'));\r\n};\r\n/*********************\r\n * Repeat given async callback function.\r\n *\r\n * @param {action} Function:\r\n * the function that will be executed repeatedly.\r\n * NOTE: Function must returns boolean.\r\n * @param {timesoutResolve} boolean: true to allow this function to return false.\r\n * @param {times} number: Number that how many times repeat.\r\n * Default to 10.\r\n * @param {interval} number: Microseconds that repeat interval.\r\n * Default to 200.\r\n * @return {Promise} Promise objects represents boolean. True as matched, false as no-matched.\r\n * @throws\r\n *\r\n * Ref：https://stackoverflow.com/questions/61908676/convert-setinterval-to-promise\r\n *\r\n * Ref：https://levelup.gitconnected.com/how-to-turn-settimeout-and-setinterval-into-promises-6a4977f0ace3\r\n * */\r\nexport const repeatActionPromise = (action, timeoutAsResolve = false, interval = 200, times = 10) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => {\r\n        let intervalId;\r\n        let triesLeft = times;\r\n        intervalId = setInterval(function () {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (yield action()) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了としてtrueを返す\r\n                    resolve(true);\r\n                }\r\n                else if (triesLeft <= 1 && timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了でfalseを返す\r\n                    resolve(false);\r\n                }\r\n                else if (triesLeft <= 1 && !timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 例外エラーとしてcatchされる\r\n                    reject();\r\n                }\r\n                triesLeft--;\r\n            });\r\n        }, interval);\r\n    });\r\n});\r\n/****************\r\n * Wrapper of setTimeout with given function.\r\n *\r\n *\r\n * */\r\nexport const delay = (action, timer) => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(function () {\r\n            const r = action();\r\n            resolve(r);\r\n        }, timer);\r\n    });\r\n};\r\n// --- USAGE EXAMPLE --------------------------------------\r\n// const randomMath = (): boolean => {\r\n//   return Math.random() * 0.8 > 400 ? true : false;\r\n// }\r\n// const repeatQuerySelector = async (): Promise<boolean> => {\r\n//   try {\r\n//     // 第二引数をfalseにすると、ループで一度もマッチしなかった場合、例外エラーになる\r\n//     // なので例外エラーにしたくなくて、falseも受け取りたいときは\r\n//     // 第二引数をtrueにすること\r\n//       const r: boolean = await repeatActionPromise(\r\n//           function(): boolean {return randomMath()}, true\r\n//       );\r\n//       return r;\r\n//   }\r\n//   catch(err) {\r\n//\r\n//       // console.error(`Error: Could not query dom. ${err.message}`)\r\n//       throw err;\r\n//   }\r\n// }\r\n// (async function() {\r\n//   const res = await repeatQuerySelector();\r\n//\r\n//\r\n// })();\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/**\r\n * Generate funciton that repeats itself asynchronously.\r\n *\r\n * @param {number} interval - Milli sec time while interval.\r\n * @param {unknownAsyncCallback} callback - Function that will be run repeatedly.\r\n * @param {unknownConditionFunc} condition - Function that decides to continue or solved by check returned value from callback.\r\n * @param {number} upTo - Repeat up to this number.\r\n * @returns {}\r\n * */\r\nexport const repeatPromiseGenerator = function (\r\n// インターバル間隔\r\ninterval, \r\n// setIntervalへ渡すコールバック関数\r\ncallback, \r\n// callbackの戻り値を判定する関数\r\ncondition, \r\n// 何回繰り返すのか\r\nupTo) {\r\n    return function () {\r\n        return new Promise((resolve, reject) => {\r\n            let intervalId;\r\n            let counter = 0;\r\n            intervalId = setInterval(function () {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    if (counter >= upTo) {\r\n                        clearInterval(intervalId);\r\n                        reject();\r\n                        // reject時に返す値も予め用意できない\r\n                    }\r\n                    const result = yield callback();\r\n                    if (condition(result)) {\r\n                        clearInterval(intervalId);\r\n                        resolve(result);\r\n                    }\r\n                    else\r\n                        counter++;\r\n                });\r\n            }, interval);\r\n        });\r\n    };\r\n};\r\n// //\r\n// // ---- USAGE --------------------------------------------------------------------\r\n// // codesandboxで動作確認可能\r\n// //\r\n// type asyncUnknownFunc<T> = (...args: any[]) => Promise<T>;\r\n// type unknownFunc<T> = (arg: T) => boolean;\r\n// interface subtitle_piece {\r\n//     subtitle: string;\r\n// }\r\n// const INTERVAL_TIME: number = 1000;\r\n// // 繰り返し実行したい関数\r\n// const callback_ = async (): Promise<subtitle_piece[]> => {\r\n//     // returns promise\r\n//     return [\r\n//         { subtitle: 'this is subtitle' },\r\n//         { subtitle: 'this is subtitle' },\r\n//         { subtitle: 'this is subtitle' },\r\n//         { subtitle: 'this is subtitle' },\r\n//         { subtitle: 'this is subtitle' },\r\n//         { subtitle: 'this is subtitle' },\r\n//     ];\r\n// };\r\n// // 繰り返し実行したい関数の戻り値を検査して判定結果をbooleanで返す関数\r\n// const condition_ = (operand: subtitle_piece[]): boolean => {\r\n//     // condition check\r\n//     // return result as boolean;\r\n//     return Math.floor(Math.random() * 9) ? true : false;\r\n// };\r\n// (async function () {\r\n//     try {\r\n//         const repeactCaptureSubtitlesTenTimes = repeatPromiseGenerator<subtitle_piece[]>(\r\n//             INTERVAL_TIME,\r\n//             callback_,\r\n//             condition_,\r\n//             10\r\n//         );\r\n//         const result: subtitle_piece[] = await repeactCaptureSubtitlesTenTimes();\r\n//\r\n//     } catch (e) {\r\n//         console.error(e);\r\n//     }\r\n// })();\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**********************************************************\r\n * background.ts\r\n *\r\n * Background script as service worker in accordance with Manifest V3.\r\n *\r\n * alert\r\n * ********************************************************/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { _key_of_localstorage__, urlPattern, orderNames, extensionNames, messageTemplate, } from '../utils/constants';\r\nimport { sendMessageToTabsPromise, exciseBelowHash, tabQuery, } from '../utils/helpers';\r\nimport { modelBase } from './annotations';\r\nimport { circulater } from '../utils/Circulater';\r\nimport { repeatPromiseGenerator } from '../utils/repeatPromise';\r\n//\r\n// --- GLOBALS -----------------------------------------------\r\n//\r\nconst INTERVAL_TIME = 100;\r\n//\r\n// --- Chrome API Listeners ---------------------------------\r\n//\r\n/**\r\n * Set up state module and clear previous storage information that state use.\r\n * Set modelBase as initial value of state module.\r\n *\r\n * Everytime this fires, this clears state.\r\n *\r\n * @callback\r\n * @param {chrome.runtime.InstalledDetails} details\r\n * - Represents details of install or update.\r\n *\r\n * */\r\nchrome.runtime.onInstalled.addListener((details) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        state.clearAll();\r\n        state.set(modelBase);\r\n    }\r\n    catch (err) {\r\n        alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n    }\r\n}));\r\n/**\r\n * Monitor events of interest by filtering all events on the browser.\r\n *\r\n * NOTE: chrome.tabs.onUpdated.addListenerにはfiltering機能がない\r\n * なのでイベントの取捨選択はすべて条件分岐を追加して対処している\r\n *\r\n * 機能：\r\n *\r\n * 1. 次のイベントを無視する\r\n *\r\n * - 指定のURL以外のページのイベントすべて\r\n * - 拡張機能が展開済であるが、changeInfo.statusが'loading'ではない\r\n * - 拡張機能が展開済であるが、展開しているタブ以外に切り替わったとき\r\n * - ブラウザが閉じられた、タブが閉じられたときの対処はchrome.tabs.onRemoved.addListenerが請け負う\r\n *\r\n * 2. 次のイベントは監視する\r\n *\r\n * - 拡張機能が展開中のタブでリロードが起こった\r\n * - 拡張機能が展開中のタブが別のURLへ移動した\r\n * - 拡張機能が展開中のタブでURL末尾(#含まない)が更新された(次の講義動画に切り替わった)\r\n * - 拡張機能が展開中のタブでURL末尾(#含まない)が更新された(講義動画がないページに切り替わった)\r\n *\r\n *\r\n * 3. URLの比較は#以下を無視して行われる\r\n *\r\n * */\r\nchrome.tabs.onUpdated.addListener((tabIdUpdatedOccured, changeInfo, Tab) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { url, tabId, isExTranscriptStructured } = yield state.get();\r\n    try {\r\n        // 拡張機能が未展開、changeInfo.statusがloadingでないなら無視する\r\n        if (changeInfo.status !== 'loading' || !isExTranscriptStructured)\r\n            return;\r\n        // 拡張機能が展開済だとして、tabIdが展開済のtabId以外に切り替わったなら無視する\r\n        if (tabIdUpdatedOccured !== tabId)\r\n            return;\r\n        // 展開中のtabId && chnageInfo.urlがUdemy講義ページ以外のURLならば\r\n        // 拡張機能OFFの処理へ\r\n        if (isExTranscriptStructured && tabIdUpdatedOccured === tabId) {\r\n            // おなじURLでのリロードか？\r\n            if (changeInfo.url === undefined) {\r\n                yield state.set(modelBase);\r\n            }\r\n            else if (!changeInfo.url.match(urlPattern)) {\r\n                // Udemy講義ページ以外に移動した\r\n                yield state.set(modelBase);\r\n            }\r\n            // 展開中のtabIdである && changeInfo.urlが講義ページである\r\n            // その上でURLが変化した\r\n            // NOTE: Compare URL WITHOUT below hash.\r\n            else if (changeInfo.url.match(urlPattern) &&\r\n                exciseBelowHash(changeInfo.url) !== exciseBelowHash(url)) {\r\n                //NOTE: MUST Update URL. ページが切り替わったから\r\n                yield state.set({ url: exciseBelowHash(changeInfo.url) });\r\n                // 動画ページ以外に切り替わった？\r\n                const res = yield sendMessageToTabsPromise(tabId, {\r\n                    from: extensionNames.background,\r\n                    to: extensionNames.contentScript,\r\n                    order: [orderNames.isPageIncludingMovie],\r\n                });\r\n                res.isPageIncludingMovie\r\n                    ? // 次の動画に移った\r\n                        yield handlerOfReset(tabIdUpdatedOccured, yield circulateCaptureSubtitles())\r\n                    : // 動画を含まないページへ移った\r\n                        yield handlerOfHide(tabIdUpdatedOccured);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        alertHandler(tabId, messageTemplate.appCannotExecute);\r\n    }\r\n}));\r\n/**\r\n * Handler for onRemoved event.\r\n *\r\n * When tab or window closed,\r\n * restore background script state as its initial state.\r\n *\r\n * Of course there is no content script after this happens.\r\n * So no need to \"turn off\" content script.\r\n *\r\n * */\r\nchrome.tabs.onRemoved.addListener((_tabId, removeInfo) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { tabId } = yield state.get();\r\n        if (_tabId !== tabId)\r\n            return;\r\n        yield state.set(modelBase);\r\n    }\r\n    catch (err) {\r\n        console.error(err);\r\n    }\r\n}));\r\n/**\r\n * Handler of onMessage\r\n *\r\n * NOTE: MUST RETURN true.\r\n * */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    if (message.to !== extensionNames.background)\r\n        return;\r\n    sortMessage(message, sender, sendResponse);\r\n    return true;\r\n});\r\n//\r\n// --- Message Handlers ----------------------------------------\r\n//\r\n/**\r\n * Sort message by sender.\r\n *\r\n * */\r\nconst sortMessage = (message, sender, sendResponse) => {\r\n    switch (message.from) {\r\n        case extensionNames.popup:\r\n            handlerOfPopupMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.contentScript:\r\n            handlerOfContentScriptMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.captureSubtitle:\r\n            handlerOfCaptureSubtitleMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.controller:\r\n            handlerOfControllerMessage(message, sender, sendResponse);\r\n            break;\r\n    }\r\n};\r\n/**\r\n * Handler of message from popup script.\r\n *\r\n * Handler will receive three orders.\r\n *\r\n * 1. sendStatus: Respond current status of state to popup.\r\n * 2. run: Run extension.\r\n * 3. turnOff: Turn off extension.\r\n *\r\n * It is at the top of the processing stage\r\n * so that exception catching is possible\r\n * in case an exception occurs and\r\n * `finally` return response\r\n * unless exception occurs.\r\n * */\r\nconst handlerOfPopupMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { from, order } = message, rest = __rest(message, [\"from\", \"order\"]);\r\n    let response = {\r\n        from: extensionNames.background,\r\n        to: from,\r\n    };\r\n    if (order && order.length) {\r\n        // SEND STATUS\r\n        if (order.includes(orderNames.sendStatus)) {\r\n            try {\r\n                const { isSubtitleCapturing, isExTranscriptStructured } = yield state.get();\r\n                response.state = {\r\n                    isSubtitleCapturing: isSubtitleCapturing,\r\n                    isExTranscriptStructured: isExTranscriptStructured,\r\n                };\r\n                response.complete = true;\r\n            }\r\n            catch (e) {\r\n                response.complete = false;\r\n                response.error = e;\r\n                alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n        // RUN\r\n        /*\r\n      - falseが返される理由\r\n        字幕がONじゃない、トランスクリプトがONじゃない、字幕が英語じゃない\r\n        \r\n      - RUN処理中、起こりうる可能性がきわめて低い問題\r\n        chrome.scripting.execute()中のエラー\r\n        字幕が取得できない（条件がそろってから実行するから、取得できないのはおかしい）\r\n        \r\n      - 起こったら終了な問題(例外判定)\r\n        DOMが取得できない（DOMの種類による）\r\n        chrome.runtime.onInstalledが実行されていないことによる、stateの未初期化\r\n    */\r\n        if (order.includes(orderNames.run)) {\r\n            try {\r\n                const r = yield handlerOfRun(rest.tabInfo);\r\n                response.success = r;\r\n                response.complete = true;\r\n                if (!r) {\r\n                    alertHandler((yield tabQuery()).id, messageTemplate.letPagePrepare);\r\n                }\r\n            }\r\n            catch (e) {\r\n                response.complete = false;\r\n                response.error = e;\r\n                alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n        // POPUP上のOFF操作による拡張機能のOFF命令\r\n        if (order.includes(orderNames.turnOff)) {\r\n            try {\r\n                yield handlerOfTurnOff();\r\n                response.complete = true;\r\n            }\r\n            catch (e) {\r\n                response.complete = false;\r\n                response.error = e;\r\n                alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n    }\r\n});\r\n/**\r\n * Handler of message from contentScrip.js.\r\n *\r\n * contentScript sends status of page to embed.\r\n * Message will have up to two status.\r\n *\r\n * - Transcript is turning on or not.\r\n * - Subtitle language is English or not.\r\n *\r\n * Whichever is false, Extension turns off ExTranscript.\r\n * Both are true, then reset ExTranscript.\r\n * */\r\nconst handlerOfContentScriptMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { from, order } = message, rest = __rest(message, [\"from\", \"order\"]);\r\n    let response = {\r\n        from: extensionNames.background,\r\n        to: from,\r\n    };\r\n    const { isExTranscriptStructured, isTranscriptDisplaying, isEnglish, tabId, } = yield state.get();\r\n    if (order && order.length) {\r\n    }\r\n    // ExTRanscriptを表示する条件が揃わなくなったとき...\r\n    // if (!rest.isTranscriptDisplaying || !rest.language) {\r\n    if ((rest.isTranscriptDisplaying !== undefined &&\r\n        !rest.isTranscriptDisplaying) ||\r\n        (rest.language !== undefined && !rest.language)) {\r\n        try {\r\n            // ExTranscriptを非表示にするかする\r\n            // もしもトランスクリプトが表示中であったならば\r\n            if (isExTranscriptStructured && isTranscriptDisplaying) {\r\n                yield handlerOfHide(tabId);\r\n            }\r\n            // あとはStateを更新するだけ\r\n            let s = {};\r\n            if (rest.isTranscriptDisplaying !== undefined) {\r\n                s['isTranscriptDisplaying'] = rest.isTranscriptDisplaying;\r\n            }\r\n            if (rest.language !== undefined) {\r\n                s['isEnglish'] = rest.language;\r\n            }\r\n            yield state.set(s);\r\n            response.complete = true;\r\n        }\r\n        catch (e) {\r\n            response.complete = false;\r\n            alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n        }\r\n        finally {\r\n            sendResponse(response);\r\n        }\r\n    }\r\n    // トランスクリプトが再表示されたとき...\r\n    if (rest.isTranscriptDisplaying) {\r\n        // ExTranscriptが非表示だったならば再表示させる\r\n        if (isExTranscriptStructured && !isTranscriptDisplaying) {\r\n            try {\r\n                yield handlerOfReset(tabId, (yield state.get()).subtitles);\r\n                yield state.set({ isTranscriptDisplaying: true });\r\n                response.complete = true;\r\n            }\r\n            catch (e) {\r\n                response.complete = false;\r\n                alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n    }\r\n    // 字幕が英語を選択されたとき...\r\n    if (rest.language) {\r\n        // ExTranscriptが非表示だったならば再表示させる\r\n        if (isExTranscriptStructured && !isEnglish) {\r\n            try {\r\n                yield handlerOfReset(tabId, (yield state.get()).subtitles);\r\n                yield state.set({\r\n                    isTranscriptDisplaying: true,\r\n                    isEnglish: true,\r\n                });\r\n                response.complete = true;\r\n            }\r\n            catch (e) {\r\n                response.complete = false;\r\n                alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n            }\r\n            finally {\r\n                sendResponse(response);\r\n            }\r\n        }\r\n    }\r\n});\r\n/**\r\n * Handler of message from captureSubtitle.js.\r\n *\r\n * So far, there is no turnout unless exception happens.\r\n * */\r\nconst handlerOfCaptureSubtitleMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { order } = message, rest = __rest(message, [\"order\"]);\r\n        if (rest.error)\r\n            throw rest.error;\r\n    }\r\n    catch (e) {\r\n        alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n    }\r\n});\r\n/**\r\n *  Handler of message from controller.js\r\n *\r\n * In case close button on ExTranscript is clicked,\r\n * then order \"turnOff\" will be sent.\r\n * */\r\nconst handlerOfControllerMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { order } = message, rest = __rest(message, [\"order\"]);\r\n        if (order && order.length) {\r\n            if (order.includes(orderNames.turnOff))\r\n                yield handlerOfTurnOff();\r\n        }\r\n        if (rest.error)\r\n            throw rest.error;\r\n    }\r\n    catch (e) {\r\n        alertHandler((yield tabQuery()).id, messageTemplate.appCannotExecute);\r\n    }\r\n});\r\n//\r\n// --- MAJOUR HANDLERS ------------------------------------------\r\n//\r\n/**\r\n * Handler of RUN order.\r\n *\r\n * @return {boolean} - true as success. false as failed. Not includes exception.\r\n * \"false\" does not mean that the application is not executable.\r\n * \"false\" mainly means that web page condition is not ready to run this application.\r\n * @throws - Exception means that application does not executable.\r\n *\r\n * To complete run, there are five phase in this handler.\r\n *\r\n * 1. Save tab info, url, tabId.\r\n * 2. Inject contentScript.ts to know page status.\r\n * 3. Inject captureSubtitle.ts to capture subtitle data.\r\n * 4. Inject controller.ts to controll ExTranscript.\r\n * 5. Send subtitle data to controller.ts to display new subtitles.\r\n *\r\n * TODO: Too huge. Need refactor.\r\n * */\r\nconst handlerOfRun = (tabInfo) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { url, id } = tabInfo;\r\n        const { isContentScriptInjected, isCaptureSubtitleInjected, isControllerInjected, } = yield state.get();\r\n        // Save valid url and current tab that extension popup opened.\r\n        yield state.set({\r\n            url: exciseBelowHash(url),\r\n            tabId: id,\r\n            tabInfo: tabInfo,\r\n        });\r\n        //<phase 2> inject contentScript.js\r\n        const { tabId } = yield state.get();\r\n        if (!isContentScriptInjected) {\r\n            yield chrome.scripting.executeScript({\r\n                target: { tabId: tabId },\r\n                files: ['contentScript.js'],\r\n            });\r\n            yield state.set({ isContentScriptInjected: true });\r\n        }\r\n        else {\r\n            yield sendMessageToTabsPromise(tabId, {\r\n                from: extensionNames.background,\r\n                to: extensionNames.contentScript,\r\n                order: [orderNames.reset],\r\n            });\r\n        }\r\n        const currentPageStatus = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.contentScript,\r\n            order: [orderNames.sendStatus],\r\n        });\r\n        yield state.set({\r\n            isEnglish: currentPageStatus.language,\r\n            isTranscriptDisplaying: currentPageStatus.isTranscriptDisplaying,\r\n        });\r\n        if (!currentPageStatus.language ||\r\n            !currentPageStatus.isTranscriptDisplaying) {\r\n            return false;\r\n        }\r\n        // <phase 3> inject captureSubtitle.js\r\n        // 字幕データを取得する\r\n        if (!isCaptureSubtitleInjected) {\r\n            yield chrome.scripting.executeScript({\r\n                target: { tabId: tabId },\r\n                files: ['captureSubtitle.js'],\r\n            });\r\n            yield state.set({ isCaptureSubtitleInjected: true });\r\n        }\r\n        // 字幕取得できるまで10回は繰り返す関数で取得する\r\n        // NOTE: 戻り値が空の配列でも受け入れる\r\n        const subtitles = yield circulateCaptureSubtitles();\r\n        yield state.set({ subtitles: subtitles });\r\n        // <phase 4> inject controller.js\r\n        if (!isControllerInjected) {\r\n            yield chrome.scripting.executeScript({\r\n                target: { tabId: tabId },\r\n                files: ['controller.js'],\r\n            });\r\n            yield state.set({ isControllerInjected: true });\r\n        }\r\n        else {\r\n            yield sendMessageToTabsPromise(tabId, {\r\n                from: extensionNames.background,\r\n                to: extensionNames.controller,\r\n                order: [orderNames.reset],\r\n            });\r\n        }\r\n        const s = yield state.get();\r\n        yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            subtitles: s.subtitles,\r\n        });\r\n        yield state.set({ isExTranscriptStructured: true });\r\n        // NOTE: MUST RETURN TRUE\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        console.error(e.message);\r\n        throw e;\r\n    }\r\n});\r\n/**\r\n * Handler of RESET\r\n *\r\n * ExTranscriptを再生成する\r\n *\r\n * 処理内容：\r\n *\r\n * - 各content scriptのリセット処理\r\n *  一度injectしたcontent scriptはプログラムで除去する手段はないため\r\n *\r\n * - controller.jsへ字幕データを渡す\r\n *\r\n * NOTE: 字幕データはこの関数の外部から取得する\r\n * */\r\nconst handlerOfReset = (tabId, subtitles) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        yield state.set({\r\n            isTranscriptDisplaying: false,\r\n            isSubtitleCaptured: false,\r\n            isSubtitleCapturing: true,\r\n        });\r\n        yield resetEachContentScript(tabId);\r\n        yield state.set({\r\n            isSubtitleCaptured: true,\r\n            isSubtitleCapturing: false,\r\n            subtitles: subtitles,\r\n        });\r\n        yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.reset],\r\n        });\r\n        yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            subtitles: subtitles,\r\n        });\r\n        yield state.set({\r\n            isTranscriptDisplaying: true,\r\n        });\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/**\r\n * Handler of HIDE ExTranscript.\r\n *\r\n * NOTE: これは拡張機能をOFFにするハンドラではない\r\n * 実際には隠すのではなくて、ExTranscriptを消す処理を実行する\r\n * handlerOfTurnOff()と区別する\r\n *\r\n * そのためstateの値はほぼそのままである\r\n *\r\n * */\r\nconst handlerOfHide = (tabId) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        // stateの更新：\r\n        yield state.set({\r\n            isTranscriptDisplaying: false,\r\n            isSubtitleCaptured: false,\r\n            // subtitles: [],\r\n        });\r\n        // reset 処理: 各content scritpのリセットを実施する\r\n        yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.turnOff],\r\n        });\r\n    }\r\n    catch (e) {\r\n        console.error(e.message);\r\n        throw e;\r\n    }\r\n});\r\n/**\r\n * Handler of TURN OFF ExTranscript.\r\n *\r\n * 各content scriptを初期化する\r\n * stateを初期化する\r\n * ただしcontent scriptのinject状況だけstateに反映させておく\r\n * */\r\nconst handlerOfTurnOff = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { tabId } = yield state.get();\r\n        yield turnOffEachContentScripts(tabId);\r\n        const { isContentScriptInjected, isCaptureSubtitleInjected, isControllerInjected, } = yield state.get();\r\n        // content scriptのinject状況だけ反映させてstateを初期値に戻す\r\n        yield state.set(Object.assign(Object.assign({}, modelBase), { isContentScriptInjected: isContentScriptInjected, isCaptureSubtitleInjected: isCaptureSubtitleInjected, isControllerInjected: isControllerInjected }));\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n//\r\n// ---- OTHER METHODS ----------------------------------------\r\n//\r\n/**\r\n * Reset each content script.\r\n *\r\n * contentScript.ts, controller.tsへリセット命令を発信する\r\n * 両scriptで完了の返信があった時点でリセット完了となる\r\n *\r\n * NOTE: turnOffEachContentScripts()と区別する\r\n * */\r\nconst resetEachContentScript = (tabId) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const contentScript = sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.contentScript,\r\n            order: [orderNames.reset],\r\n        });\r\n        const controller = sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.reset],\r\n        });\r\n        yield Promise.all([contentScript, controller]);\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/**\r\n * Turn Off each content script.\r\n *\r\n * contentScript.ts, controller.tsへ初期化命令(TurnOff)を発信する\r\n * 両scriptで完了の返信があった時点でリセット完了となる\r\n *\r\n * NOTE: resetEachContentScripts()と区別する\r\n * */\r\nconst turnOffEachContentScripts = (tabId) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const contentScript = sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.contentScript,\r\n            order: [orderNames.turnOff],\r\n        });\r\n        const controller = sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.turnOff],\r\n        });\r\n        yield Promise.all([contentScript, controller]);\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/***\r\n * Repeat subtitle acquisition 10 times.\r\n *\r\n * @returns function - Returns a function which repeats second argument callback function while given times or untile third argument function returns true.\r\n * */\r\nconst captureSubtitles = repeatPromiseGenerator(INTERVAL_TIME, function () {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const { tabId } = yield state.get();\r\n        const r = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.captureSubtitle,\r\n            order: [orderNames.sendSubtitles],\r\n        });\r\n        return r.subtitles;\r\n    });\r\n}, function (data) {\r\n    return data !== undefined && data.length ? true : false;\r\n}, 10);\r\n/**\r\n * circulateCaptureSubtitles\r\n *\r\n *\r\n * description:\r\n * captureSubtitles()を3回繰り返す関数\r\n * condition()の条件を満たせば即終了し、\r\n * repeactCaptureSubtitles()が取得した最後の戻り値を返す\r\n *\r\n * UdemyのDOMローディングの時間がかかりすぎる場合に対処するための関数\r\n *\r\n * @returns function - Async function that repeats given function untile given times.\r\n * */\r\nconst circulateCaptureSubtitles = circulater(captureSubtitles, (operand) => {\r\n    return operand.length ? true : false;\r\n}, 2);\r\n/**\r\n * Alert\r\n *\r\n * Embeds alert function into content script.\r\n */\r\nconst alertHandler = (tabId, msg) => {\r\n    chrome.scripting.executeScript({\r\n        target: { tabId: tabId },\r\n        func: function (msg) {\r\n            alert(msg);\r\n        },\r\n        args: [msg],\r\n    });\r\n};\r\n/***\r\n * state module\r\n *\r\n *\r\n * This module never holds variables.\r\n * No matter background script unloaded or reloaded,\r\n * state never lose saved varibales.\r\n * */\r\nconst state = (function () {\r\n    const _getLocalStorage = function (key) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((resolve, reject) => {\r\n                chrome.storage.local.get(key, (s) => {\r\n                    if (chrome.runtime.lastError)\r\n                        reject(chrome.runtime.lastError);\r\n                    resolve(s);\r\n                });\r\n            });\r\n        });\r\n    };\r\n    return {\r\n        // 本来ローカルストレージに保存しておくデータの一部だけでも\r\n        // 保存することを可能とする\r\n        //\r\n        set: (prop) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const s = yield _getLocalStorage(_key_of_localstorage__);\r\n                const newState = Object.assign(Object.assign({}, s[_key_of_localstorage__]), prop);\r\n                yield chrome.storage.local.set({\r\n                    [_key_of_localstorage__]: newState,\r\n                });\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n        }),\r\n        get: () => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const s = yield _getLocalStorage(_key_of_localstorage__);\r\n                return Object.assign({}, s[_key_of_localstorage__]);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n        }),\r\n        clearAll: () => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield chrome.storage.local.remove(_key_of_localstorage__);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n        }),\r\n    };\r\n})();\r\n"],"names":[],"sourceRoot":""}